set upDown := up down;

set sense := greater_than, less_than, equal;
set sense_greater_than := greater_than;
set sense_less_than := less_than;
set sense_equal := equal;

set ct_method := 
  none
  constant_efficiency
  min_load_efficiency
  no_losses_no_variable_cost
  variable_cost_only
  regular
  exact
;

set startup_method :=
  no_startup
  linear
  binary
;

set ramp_method :=
  ramp_limit
  ramp_cost
  both
;

set fork_method :=
  fork_no
  fork_yes
; 
set fork_method_yes := fork_yes;
set fork_method_no := fork_no;

set ramp_cost_method := ramp_cost both;
set ramp_limit_method := ramp_limit both;


set method :=
  method_1way_1var_off
  method_1way_1var_LP
  method_1way_1var_MIP
  method_1way_nvar_off
  method_1way_nvar_LP
  method_1way_nvar_MIP
  method_2way_1var_off
  method_2way_2var_off
  method_2way_2var_exclude
  method_2way_2var_MIP_exclude
  method_2way_nvar_off
  not_applicable
;

set method_1var := method_1way_1var_off, method_2way_1var_off;
set method_1var_off := method_1way_1var_off, method_2way_1var_off; 
set method_1way_off := method_1way_1var_off, method_1way_nvar_off;
set method_2way_off := method_2way_1var_off, method_2way_2var_off, method_2way_2var_exclude, method_2way_nvar_off; 
set method_1way_1var_on := method_1way_1var_LP, method_1way_1var_MIP; 
set method_1way_nvar_on := method_1way_nvar_LP, method_1way_nvar_MIP; 
set method_1way_LP := method_1way_1var_LP, method_1way_nvar_LP;
set method_1way_MIP := method_1way_1var_MIP, method_1way_nvar_MIP;
set method_1way := method_1way_1var_off, method_1way_1var_LP, method_1way_1var_MIP, 
                   method_1way_nvar_off, method_1way_nvar_LP, method_1way_nvar_MIP; 
set method_2way := method_2way_1var_off, method_2way_2var_off, method_2way_2var_exclude, 
                   method_2way_2var_MIP_exclude, method_2way_nvar_off;
set method_off := method_1way_1var_off, method_1way_nvar_off, method_2way_1var_off, 
                  method_2way_2var_exclude, method_2way_2var_off, method_2way_nvar_off;  
set method_1way_on := method_1way_1var_LP, method_1way_1var_MIP, method_1way_nvar_off, 
                      method_1way_nvar_LP, method_1way_nvar_MIP; 
set method_2way_on := method_2way_2var_exclude, method_2way_2var_MIP_exclude;
set method_on := method_1way_1var_LP, method_1way_1var_MIP, method_1way_nvar_LP, 
                 method_1way_nvar_MIP, method_2way_2var_MIP_exclude;
set method_nvar := method_1way_nvar_off, method_1way_nvar_LP, method_1way_nvar_MIP, 
                   method_2way_nvar_off;

set method_1way_1var := method_1way_1var_off, method_1way_1var_LP, method_1way_1var_MIP, method_1way_nvar_off;
set method_2way_1var := method_2way_1var_off;
set method_2way_2var := method_2way_2var_off, method_2way_2var_exclude, method_2way_2var_MIP_exclude;
set method_2way_nvar := method_2way_nvar_off;
set method_LP := method_1way_1var_LP, method_1way_1var_MIP, method_1way_nvar_off, 
                 method_1way_nvar_LP;
set method_MIP := method_1way_1var_MIP, method_1way_nvar_MIP, method_2way_2var_MIP_exclude;
set method_direct := method_1way_1var_off, method_1way_1var_LP, method_1way_1var_MIP, 
                     method_2way_1var_off, method_2way_2var_off, method_2way_2var_exclude, 
					 method_2way_2var_MIP_exclude;
set method_indirect := method_1way_nvar_off, method_1way_nvar_LP, method_1way_nvar_MIP, 
                       method_2way_nvar_off;
set method_1var_per_way := method_1way_1var_off, method_1way_1var_LP, method_1way_1var_MIP, 
                           method_2way_2var_off, method_2way_2var_exclude, method_2way_2var_MIP_exclude;

set methods := 
(constant_efficiency, no_startup, fork_no, method_1way_1var_off)
(constant_efficiency, no_startup, fork_yes, method_1way_nvar_off)
(constant_efficiency, linear, fork_no, method_1way_nvar_LP)
(constant_efficiency, linear, fork_yes, method_1way_nvar_LP)
(constant_efficiency, binary, fork_no, method_1way_nvar_MIP)
(constant_efficiency, binary, fork_yes, method_1way_nvar_MIP)
(no_losses_no_variable_cost, no_startup, fork_no, method_2way_1var_off)
(no_losses_no_variable_cost, no_startup, fork_yes, method_2way_nvar_off)
(variable_cost_only, no_startup, fork_no, method_2way_2var_off)
(variable_cost_only, no_startup, fork_yes, method_2way_nvar_off)
(regular, no_startup, fork_no, method_2way_2var_exclude)
(regular, no_startup, fork_yes, not_applicable)
(exact, no_startup, fork_no, method_2way_2var_MIP_exclude)
(exact, no_startup, fork_yes, not_applicable)
(min_load_efficiency, no_startup, fork_no, not_applicable)
(min_load_efficiency, no_startup, fork_yes, not_applicable)
(min_load_efficiency, linear, fork_no, method_1way_nvar_LP)
(min_load_efficiency, linear, fork_yes, method_1way_nvar_LP)
(min_load_efficiency, binary, fork_no, method_1way_nvar_MIP)
(min_load_efficiency, binary, fork_yes, method_1way_nvar_MIP)
(none, no_startup, fork_no, method_1way_1var_off)
(none, no_startup, fork_yes, method_1way_nvar_off)
(none, linear, fork_no, method_1way_1var_LP)
(none, linear, fork_yes, method_1way_nvar_LP)
(none, binary, fork_no, method_1way_1var_MIP)
(none, binary, fork_yes, method_1way_nvar_MIP)
;

set commodityParam := price, co2_content;
set commodityPeriodParam := price;
set processParam := efficiency existing fixed_cost interest_rate invest_cost salvage_value
                    invest_max_period invest_max_total lifetime
					invest_min_period invest_min_total
                    retire_forced retire_max_period retire_max_total variable_cost 
					efficiency_at_min_load min_load min_downtime min_uptime
					startup_cost virtual_unitsize;
set processPeriodParam := fixed_cost interest_rate invest_cost salvage_value
                    invest_max_period invest_min_period
					lifetime variable_cost startup_cost
                    retire_forced retire_max_period retire_min_period;
set processTimeParam := efficiency efficiency_at_min_load min_load variable_cost;
set sourceSinkParam := efficiency, efficiency_at_min_load, min_load, coefficient, flow_unitsize, variable_cost, ramp_cost, ramp_limit, inertia_constant;
set sourceSinkTimeParam := efficiency, efficiency_at_min_load, min_load, variable_cost;
set nodeParam := annual_flow, existing, fixed_cost, inflow, interest_rate, invest_cost, salvage_value,
                 invest_max_total, invest_min_total, lifetime,
				 invest_max_period, invest_min_period,
                 penalty_down, penalty_up, retire_forced, retire_min_total, 
				 retire_max_total, self_discharge_loss, virtual_unitsize;
set nodePeriodParam := annual_flow, fixed_cost, interest_rate, invest_cost, salvage_value,
                 invest_max_period, invest_min_period, lifetime,
                 retire_forced, retire_max_period, retire_min_period, virtual_unitsize;
set nodeTimeParam := inflow, penalty_down, penalty_up, self_discharge_loss;
set reserveParam := reservation reliability penalty_reserve,
                    increase_reserve_ratio large_failure_ratio max_share;
set reserveTimeParam := reservation;
set invest_method := only_invest, only_retire, invest_and_retire, not_allowed;
set modelParam := solveFirst;
set groupParam := has_capacity_margin, capacity_margin, has_inertia, inertia_limit, 
                  invest_max_total, invest_min_total, invest_max_period, invest_min_period,
				  non_synchronous_limit, co2_price, penalty_inertia, penalty_non_synchronous
				  max_cumulative_flow, min_cumulative_flow, max_instant_flow, min_instant_flow,
				  output_results;
set groupPeriodParam := capacity_margin, co2_price, inertia_limit, invest_max_period,
                  invest_min_period, max_cumulative_flow, min_cumulative_flow,
				  non_synchronous_limit, penalty_inertia, penalty_non_synchronous,
				  max_instant_flow, min_instant_flow;
set invest_method_not_allowed := not_allowed;
set profile_method := upper_limit lower_limit fixed;
set inflow_method := use_original scale_to_annual_flow no_inflow;
set reserve_method := no_reserve timeseries_only dynamic_only both;


set test_dt := (p2020, t0001);
#set test_dt := (p2020, t0001) (p2020, t0009) (p2020, t0015) (p2020, t0020) (p2020, t0024);
end;